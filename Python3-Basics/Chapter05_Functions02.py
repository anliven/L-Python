#! python3
# -*- coding: utf-8 -*-


def fact(n):  # 计算阶乘n! = 1 * 2 * 3 * ... * n
    if 1 == n:
        return 1
    return n * fact(n - 1)


print(fact(5))
# fact(1000)  # 递归调用的次数过多导致栈溢出


def fact2(n):
    return fact_iter(n, 1)


def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)  # 仅返回递归函数本身，参数值在函数调用前就会被计算完成，不影响函数调用


print(fact2(5))
# fact2(1000)  # 递归调用的次数过多导致栈溢出

# ### 递归(Recursion)
# - 递归函数: 函数在内部调用自身本身；
# - 递归函数的优点是定义简单，逻辑清晰；
#
# ### 栈溢出
# - 函数调用是通过栈（stack）实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
# - 栈的大小不是无限的，当递归调用的次数过多时，会导致栈溢出；
#
# ### 尾递归
# - 尾递归：在函数返回时调用自身本身，并且return语句不能包含表达式；
# - 如果编译器可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，就不会出现栈溢出的情况；
# - 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，任何递归函数都存在栈溢出的问题;
