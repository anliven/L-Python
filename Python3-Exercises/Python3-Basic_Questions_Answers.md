# Python3-Basic_Questions_Answers



## 001-010

### 001 - 如何拷贝一个对象？
```
使用标准库copy模块的copy方法（返回和参数包含内容一样的对象）和deepcopy方法（对象中的属性也被复制）。
```
### 002 - pass语句的作用是什么？
```
pass语句一般用来作为占位符或者创建占位代码块，pass语句不会执行任何操作。
```
### 003 - Pyrhon中如何删除一个列表中的重复元素？
```
使用内置set()函数。
```
### 004 - 如何实现元组（tuple）和（list）之间的数据类型转换？
```
使用内置tuple()和list()函数。
```
### 005 - Lambda函数的定义？
```
- Lambda函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的单行函数(也称为匿名函数)；
- Lambda函数所包含的表达式不能超过一个，而且不能包含命令；
```
### 006 - 如何查看或判断一个python对象的类型？
```
- 查看对象类型：使用内置type()函数；
- 判断对象类型：使用内置isinstance()函数；
```
### 007 - 如何生成随机数？
```
使用标准库random模块：https://docs.python.org/3/library/random.html
```
### 008 - Python代码检查和分析工具有那些？
```
- PyChecker（http://pychecker.sourceforge.net/）
- PyLint（https://pylint.org/）
```
### 009 - 如何在函数中设置一个全局的变量？
```
Python提供了global关键字，能够在函数里面声明或修改全局变量，但不建议这样使用。
实际上，Python的全局变量是模块级别的，而不是程序级别的（全局唯一）。
模块就是一个Python文件，是一个独立的、顶层的命名空间，模块内定义的变量，都属于该命名空间。
```
### 010 - 如何删除一个文件？
```
使用os.remove()或os.unlink()方法。
```


## 011-020

### 011 - 如何拷贝一个文件？
```
使用标准库shutil模块的copyfile()方法。
```
### 012 - 如何处理中文输出问题？
```
使用字符串对象的encode()和decode()方法。
```
### 013 - 切片（Slicing）的含义？
```
Slicing是一种能够在有序的对象类型（列表，元组，字符串）中截取指定索引范围内容的语法，可以很方便地获取序列的子序列。
```
### 014 - 什么是PEP8？
```
PEPs(Python Enhancement Proposals，https://www.python.org/dev/peps/)。
PEP8(Style Guide for Python Code)是一个编程规范，关于如何让代码更具有可读性的一些建议。
具体信息（https://www.python.org/dev/peps/pep-0008/）。
```
### 015 - 文档字符串（docstring）的含义？
```
文档字符串（docstring）为函数，模块和类注释生成文档。
```
### 016 - 如何将一个数字转换成一个字符串？
```
使用内置函数str()。
```
### 017 - Python装饰器的作用？
```
简单来说，装饰器的作用就是为已经存在的对象添加额外的功能，可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。
```
### 018 - Python多线程与多进程的主要区别？
```
多线程可以共享全局变量，多进程不能；多线程的所有子线程的进程号相同，多进程的不同的子进程进程号不同。
```
### 019 - 生成器(generator)与函数的主要区别？
```
生成器是包含yield关键字的函数，在运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值；生成器返回迭代器，而函数返回值。
```
### 020 - re.match()和re.search()方法的不同？
```
- re.match()：只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
- re.search()：扫描整个字符串并返回第一个成功的匹配；
```


## 021-030

### 021 - 什么是pickling与unpickling？
```
将内容从内存中变成可存储或传输的过程称之为序列化（pickling），反之，把内容从序列化的对象重新读到内存里称之为反序列化（unpickling）。
标准库pickle模块可用来实现持久地（Persistently）存储任何纯Python对象到文件并读取。
```
### 022 - 如何理解“Python是一种解释型、交互式、面向对象、动态数据类型的高级程序设计语言”？
```
- 解释型：源代码先翻译成中间代码，再由解释器对中间代码进行解释运行；源代码在执行之前不需要编译，直接运行。
- 交互式：编写代码时可通过终端和解释器直接交互。
- 面向对象：在Python中所有的一切都是对象，包括数字、字符串与函数。
- 动态数据类型：变量不需要指定类型（编译时编译器并不知道变量的真实类型, 只有在运行时才知道其真实类型）。
- 高级程序设计语言：良好的可移植性（不依赖于具体的机器）、丰富的数据结构和控制结构、良好的可读性（便于交流和维护）。
```
### 023 - Python命名空间的含义？
```
命名空间是名称到对象的映射，是一个字典的实现，键为变量名，值是变量对应的值。
各个命名空间是独立存在，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。
- Local（局部命名空间）：运行阶段函数被调用时动态创建，记录函数中定义的所有变量，函数调用结束时动态销毁。
- Global（全局命名空间）：模块被加载时创建，记录模块中定义的变量，通常一直保留直到python解释器退出。
- Built-in（内建命名空间）：python解释器启动时创建，记录内置函数和异常，一直保留直到解释器退出。
命名空间创建顺序：python解释器启动->创建内建命名空间->加载模块->创建全局命名空间->函数被调用->创建局部命名空间
命名空间销毁顺序：函数调用结束->销毁函数对应的局部命名空间->python虚拟机（解释器）退出->销毁全局命名空间->销毁内建命名空间
```
### 024 - Python作用域的含义？
```
作用域是针对变量而言，指声明的变量在程序里的可应用范围，变量的作用域总是由在代码中被赋值的地方所决定的。
搜索顺序：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）。
```
### 025 - Python新式类与经典类（旧式类）的区别？
```
在多继承中，新式类采用广度优先搜索，而旧式类是采用深度优先搜索。
新式类更符合OOP编程思想，统一了python中的类型机制（直接通过__class__属性获取自身类型与type()的结果一致）。
相同父类的场景，新式类只执行一次构造函数，经典类重复执行多次。
新式类增加了一些内置属性和方法，例如：__slots__内置属性和__getattribute__方法。
Python2.x中默认都是经典类，只有显式继承了object才是新式类；Python3.x中默认都是新式类，经典类被移除，不必显式的继承object。
```
### 026 - Python如何获取当前的绝对路径？
```
通过标准库os模块的os.path.abspath('.')方法获取。
```
### 027 - Python如何获取当前模块的文件名？
```
通过特殊变量__file__获取。
```
### 028 - Python如何获取命令行参数?
```
通过标准库sys模块的sys.argv变量获取。
```
### 029 - 如何获取当前Python命令的可执行文件路径？
```
通过标准库sys模块的sys.executable变量获取。
```
### 030 - 如何查看所有的已成功加载的模块？
```
通过sys.modules查看。
```

## 031-040

### 031 - Python中GIL（Global Interpreter Lock）的作用？
```
GIL会确保任何时候，多个线程中只有一个线程被执行。也就是说，由于GIL的限制，Python并不支持真正意义上的多线程。
```
### 032 - Python中装饰器（decorator）的定义？
```
装饰器是一种特殊的函数，可以接受函数作为输入参数，并返回一个函数，也可以接受一个类作为输入参数，并返回一个类。
通过使用@标记（语法糖，syntactic sugar），能够以简单易读得方式装饰目标对象。
```
### 033 - 如何理解Python中函数是第一类对象（first-class objects）？
```
函数既能返回函数类型，也可以接受函数作为输入，还可以指定给变量。
Python中的类（class）也是第一类对象。
```
### 034 - “__new__”与“__init__"的区别？
```
- “__new__”：创建对象时调用，返回当前对象的一个实例； 
- “__init__”：创建对象后调用，对当前对象的一些实例初始化，无返回值；
```
### 035 - Python中变量、对象与引用的关系？
```
- 变量：不需要预先声明，在第一次赋值时被创建并指向对象，变量的类型是动态变化的，其类型与对象保持一致； 
- 对象：被分配的一块内存空间，存储其所代表的值，并且具有类型标识符和引用计数器；
- 引用：从变量到对象的指针； 
总的来说，在Python中变量和对象是分离的，对象是内存中储存数据的实体，变量则是指向对象的指针；类型属于对象，而不是变量。
```
### 036 - 可变对象与不可变对象的定义和区分？
```
不可变对象：
- 调用对象自身的方法，不会改变该对象自身的内容，而是创建新的对象（分配新的内存地址）并返回，保证了不可变对象本身不可变；
- 包括int，float，str，tuple等；

可变对象：
- 调用对象自身的方法，会改变该对象自身的内容（内存地址保持不变）；
- 包括list，set，dict等；

特别注意：
- “不可变”是指“值的不可变”；
- 函数的默认参数必须指向不可变对象；
```
### 037 - Python中赋值、浅拷贝、深拷贝的区别？
```
赋值：创建对象的一个引用；
实现赋值：“=”；

浅拷贝：复制对象，但不复制该对象中引用的其他对象（依然使用原始的引用）；
实现浅拷贝：使用完全切片[:]、使用工厂函数（list()、set()等）、使用copy模块中的copy.copy()；

深拷贝：复制对象，同时也复制该对象中引用的其他对象；
实现深拷贝：使用copy模块的copy.deepcopy()；
```
### 038 - “is”和“==”的区别?
```
- “is”：表示对象标示符（object identity），用来检查对象的标示符（内存中的地址）是否一致；
- “==”：表示相等（equality），用来检查两个对象的值是否相等；
```
### 039 - 列举至少5个PEP8规范
```
- 每级缩进用4个空格；
- 每行最大行宽不超过 79 个字符，一般续行可使用反斜杠，括号内续行不需要使用反斜杠；
- 文本块，比如文档字符串或注释，行长度应限制为72个字符；
- 两行空行用于分割顶层函数和类的定义，单个空行用于分割类定义中的方法；
- 导入的每个模块应该单独成行，按照标准库、第三方库本地库顺序导入，禁止使用通配符导入；
- 单引号和双引号作用是一样的，但必须保证成对存在，不能夹杂使用；建议句子使用双引号, 单词使用单引号；
- 。。。。。。
```
### 040 - Python中闭包的含义？
```
- 闭包（Closure）是词法闭包（Lexical Closure）的简称；
- 闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)；
- 函数引用了自由变量，被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外；
```



## 041-050

### 041 - Python中字符串格式化的方式有哪几种？
```
- 格式化操作符（%）；
- 字符串内建函数format()；
- 使用string模块中的字符串模板（Template）对象；
```
### 042 - Python中MRO的含义？
```
MRO（Method Resolution Orde）是类的方法解析顺序表，也就是继承父类方法时的顺序表。
在Python中提供了__mro__内置属性来查看类的MRO。
```
### 043 - Python中with语句的作用？
```
使用with语句可以妥善地处理上下文环境产生的异常，清理工作更简单，并且让代码更简练优雅；
with所求值的对象必须具有一个__enter__()方法和一个__exit__()方法；
紧跟with后面的语句被求值后，返回对象的__enter__()方法被调用，这个方法的返回值将被赋值给as后面的变量；
当with后面的代码块全部被执行完之后，将调用前面返回对象的__exit__()方法；
```
### 044 - 什么是super() 函数？
```
super() 函数是用于调用父类(超类)的一个方法，用来解决多重继承问题，但是super()继承只能用于新式类。
```
### 045 - 什么是反射（自省）？
```
Python中反射是指通过字符串的形式操作对象相关属性，主要用于用户交互；
常用函数：
- dir()：传入对象，返回该对象的所有属性和函数列表；
- hasattr()、getattr()、setattr()、delattr()；操作对象相关属性；
- isinstance()：确定对象的类型，返回布尔值；
- ”__doc__“、”__name__“、”__dict__“等；
```
### 046 - 如何查看全局范围内的对象？
```
利用内置函数globals()：https://docs.python.org/3/library/functions.html#globals；
```
### 047 - 内置函数“__import__()”的作用？？
```
“__import__()”是一个函数，只接收字符串作为参数，可以实现动态导入模块，常用于支持插件功能的场景；
例如，从配置文件等获取module名称（字符串类型），然后使用“__import__ (name)”动态加载module；
事实上，import本质上是调用“__import__()”加载module的；
```
### 048 - 参数“*args”和“**kwargs”的区别？
```
如果不确定要往函数中传入多少个参数，或者想往函数中以列表和元组的形式传参数时，使用“*args”。
如果不确定要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，使用“**kwargs”。
约定俗成使用args和kwargs这两个标识符，也可以用其他标识符名称（不建议）。
```
### 049 - 什么是字符串驻留机制？
```
Python的字符串驻留机制可以提高系统性能。
在Python中，将短字符串赋值给多个不同的对象时，内存中只有一个副本，多个对象共享该副本。
也就是说，对于短字符串，Python会保留其值的一个副本，当创建新的字符串时直接指向该副本。
而对于长字符串，将各自创建对象，它们的值相同但id值不同。
```
### 050 - 简述Python的特性
```
- 解释型语言：不需要在运行之前进行编译，而是边运行边解释。
- 动态类型：不需要声明变量的类型。
- 面向对象：允许定义类以及组合和继承，但没有访问修饰符。
- 函数是一等对象：可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。
- 运行速度通常比编译语言慢，但允许包含基于C的扩展来优化运行速度。
```