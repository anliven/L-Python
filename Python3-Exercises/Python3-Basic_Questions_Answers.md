# Python3-Basic_Questions_Answers



## 概念理解

### 01 - 简述Python的关键特征 
```
- 解释型：源代码在执行之前不需要编译，而是边运行边解释(解释器将源代码转换成中间语言，再翻译成机器码执行)；
- 交互式：编写代码时可通过终端和解释器直接交互；
- 面向对象：在Python中所有的一切都是对象，包括数字、字符串与函数；
- 动态数据类型：声明变量时，不需要声明变量的类型（编译时编译器并不知道变量的真实类型, 只有在运行时才知道其真实类型）；
- 高级程序设计语言：良好的可移植性（不依赖于具体的机器）、丰富的数据结构和控制结构、良好的可读性（便于交流和维护）；
- 函数是一等对象（first-class objects）：可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值；
- 支持通过组合（composition）与继承（inheritance）的方式定义类（class），但没有访问修饰符（access specifier）；
- 运行速度通常比编译语言慢，但允许包含基于C的扩展来优化运行速度；

简而言之，Python是一种解释型、交互式、面向对象、动态数据类型的高级程序设计语言，可以让开发人员专注于算法和数据结构的设计，而不用处理底层的细节；
```

### 02 - 简述Python中的内存管理机制
```
Python使用一个私有堆空间来保存所有的对象和数据结构；
解释器管理这个私有堆空间，开发者无法访问它，但可以通过核心API访问一些内容；
Python内存管理器控制内存分配；
内置垃圾回收机制（GC：Garbage Collection）基于引用计数实现自动垃圾回收，将所有未使用内存适用于堆空间；
  - 在Python中，为了解决内存泄露问题，在内存中存储了每个对象的引用计数（reference count）；
  - 如果计数值变成0，那么相应的对象就会消失，分配给该对象的内存就会释放出来用作他用；
  - 偶尔会出现引用循环（reference cycle），垃圾回收器会定时寻找这个循环，并将其回收；
```

### 03 - 简述Python中的多线程
```
虽然Python内置有多线程模块，但由于GIL（Global Interpreter Lock，全局解释器锁）的限制，Python并不支持真正意义上的多线程；
GIL会确保任何时候，多个线程中只有一个线程被执行；
一个线程保存GIL并在将其传递给下个线程之前执行一些操作，线程的执行速度非常快，表面上造成“线程并行执行”的错觉，但是实际上都是轮流执行；
```

### 04 - 简述Python中的装饰器（decorator）
```
装饰器是一种特殊的函数，可以接受函数作为输入参数，并返回一个函数，也可以接受一个类作为输入参数，并返回一个类；
通过使用@标记（语法糖，syntactic sugar），能够以简单易读得方式装饰目标对象；
简单来说，装饰器的作用就是为已经存在的对象添加额外的功能，可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用；
```

### 05 - 简述Python中的生成器（Generator）
```
生成器是包含yield语句的函数，可以生成多个值，每次一个；
每次使用yield生成一个值后，函数都将冻结（再次等待停止执行），等待被重新唤醒，被重新唤醒后，函数将从停止的地方开始继续执行；
简单的说，生成器是实现迭代器的一种机制，其功能实现依赖于yield表达式，除此之外跟普通的函数及基本一致；
```

### 06 - 简述Python中的反射（自省）
```
Python中反射是指通过字符串的形式操作对象相关属性，主要用于用户交互；
常用函数：
- dir()：传入对象，返回该对象的所有属性和函数列表；
- hasattr()、getattr()、setattr()、delattr()；操作对象相关属性；
- isinstance()：确定对象的类型，返回布尔值；
- ”__doc__“、”__name__“、”__dict__“等；
```

### 07 - 简述Python中的字符串驻留机制
```
Python的字符串驻留机制可以提高系统性能；
在Python中，将短字符串赋值给多个不同的对象时，内存中只有一个副本，多个对象共享该副本；
也就是说，对于短字符串，Python会保留其值的一个副本，当创建新的字符串时直接指向该副本；
而对于长字符串，将各自创建对象，它们的值相同但id值不同；
```

### 08 - 简述Python中的闭包
```
- 闭包（Closure）是词法闭包（Lexical Closure）的简称；
- 闭包是由函数及其相关的引用环境组合而成的实体(即：闭包=函数+引用环境)；
- 函数引用了自由变量，被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外；
```

### 09 - 简述Python中的Lambda函数
```
- Lambda函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的单行函数(也称为匿名函数)；
- Lambda函数所包含的表达式不能超过一个，而且不能包含命令；
- 简单的说，Lambda函数就是一个常被用于代码中的单个表达式的匿名函数；
```

### 10 - 简述PEP8
```
PEP8(Style Guide for Python Code)是一个编程规范，关于如何让代码更具有可读性的一些建议；
具体信息可查看：https://www.python.org/dev/peps/pep-0008/；
PEPs(Python Enhancement Proposals）：https://www.python.org/dev/peps/；

一些PEP8规范：
  - 每级缩进用4个空格；
  - 每行最大行宽不超过 79 个字符，一般续行可使用反斜杠，括号内续行不需要使用反斜杠；
  - 文本块，比如文档字符串或注释，行长度应限制为72个字符；
  - 两行空行用于分割顶层函数和类的定义，单个空行用于分割类定义中的方法；
  - 导入的每个模块应该单独成行，按照标准库、第三方库本地库顺序导入，禁止使用通配符导入；
  - 单引号和双引号作用是一样的，但必须保证成对存在，不能夹杂使用；建议句子使用双引号, 单词使用单引号；
```




## 基础定义

### 01 - 如何理解Python中函数是第一类对象（first-class objects）？
```
函数既能返回函数类型，也可以接受函数作为输入，还可以指定给变量；
Python中的类（class）也是第一类对象；
```

### 02 - Python中标识符的命名规则有哪些？
```
在Python中，命名标识符时必须遵守以下规则：
  - 只能以下划线或者字母开头；
  - 只能由字母、下划线（_）、数字（0~9）组成；
  - 区分大小写；
  - 关键字不能作为标识符；
  - 可以是任意长度；
不建议以下划线作为标识符的开头，在Python中约定俗成认为以下划线为开头的变量为私有变量；
```

### 03 - 文档字符串（docstring）的含义？
```
文档字符串（docstring）为函数，模块和类注释生成文档；
```

### 04 - 什么是切片（Slicing）？
```
切片（Slicing）是一种能够在有序的对象类型（列表，元组，字符串）中截取指定索引范围内容的语法，可以很方便地获取序列的子序列；
```

### 05 - 什么是pickling与unpickling？
```
将内容从内存中变成可存储或传输的过程称之为序列化（pickling）；
反之，把内容从序列化的对象重新读到内存里称之为反序列化（unpickling）；
标准库pickle模块可用来实现持久地（Persistently）存储任何纯Python对象到文件并读取；
```

### 06 - 什么是命名空间（namespace）？
```
命名空间是名称到对象的映射，是一个字典的实现，键为变量名，值是变量对应的值；
各个命名空间是独立存在，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响；
- Local（局部命名空间）：运行阶段函数被调用时动态创建，记录函数中定义的所有变量，函数调用结束时动态销毁；
- Global（全局命名空间）：模块被加载时创建，记录模块中定义的变量，通常一直保留直到python解释器退出；
- Built-in（内建命名空间）：python解释器启动时创建，记录内置函数和异常，一直保留直到解释器退出；
命名空间创建顺序：python解释器启动->创建内建命名空间->加载模块->创建全局命名空间->函数被调用->创建局部命名空间
命名空间销毁顺序：函数调用结束->销毁函数对应的局部命名空间->python虚拟机（解释器）退出->销毁全局命名空间->销毁内建命名空间
```

### 07 - Python作用域（scope）的含义？
```
作用域是针对变量而言，指声明的变量在程序里的可应用范围，或者称为变量的可见性；
变量的作用域总是由在代码中被赋值的地方所决定的，只有函数、类、模块会产生作用域，代码块不会产生作用域；
作用域按照变量的定义位置可以划分为4类：
  - Local(函数内部)局部作用域
  - Enclosing（嵌套函数的外层函数内部）嵌套作用域（闭包）
  - Global（模块全局）全局作用域
  - Built-in（内建）内建作用域
搜索顺序：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）；
```

### 08 - Python中with语句的作用？
```
使用with语句可以妥善地处理上下文环境产生的异常，清理工作更简单，并且让代码更简练优雅；
with所求值的对象必须具有一个__enter__()方法和一个__exit__()方法；
紧跟with后面的语句被求值后，返回对象的__enter__()方法被调用，这个方法的返回值将被赋值给as后面的变量；
当with后面的代码块全部被执行完之后，将调用前面返回对象的__exit__()方法；
```

### 09 - 什么是super()函数？
```
super()函数是用于调用父类(超类)的一个方法，用来解决多重继承问题，但是super()继承只能用于新式类；
```

### 10 - 内置函数“__import__()”的作用？？
```
“__import__()”是一个函数，只接收字符串作为参数，可以实现动态导入模块，常用于支持插件功能的场景；
例如，从配置文件等获取module名称（字符串类型），然后使用“__import__ (name)”动态加载module；
事实上，import本质上是调用“__import__()”加载module的；
```

### 11 - 类的继承有几种场景？
```
当B类继承自A类，就被称为A类的子类/派生类，B类被称为父类/基类/超类；
A类会继承/获取B类所有类成员（属性和方法）；
Python支持如下继承场景：
  - 单继承：一个类继承自单个基类；
  - 多继承：一个类继承自多个基类；
  - 多级继承：一个类继承自单个基类，后者则继承自另一个基类；
  - 分层继承：多个类继承自单个基类；
  - 混合继承：两种或多种类型继承的混合；
```

### 12 - Python中MRO的含义？
```
MRO（Method Resolution Orde）是类的方法解析顺序表，也就是继承父类方法时的顺序表；
在Python中提供了__mro__内置属性来查看类的MRO；
```

### 13 - 什么是三元运算规则？
```
Python中的三元运算规则：
- “[on true] if [expression] else [on false]”；
- 如果表达式为True就执行[on true]中的语句，否则就执行[on false]中的语句；
```

### 14 - 什么是猴子补丁（ Monkey Patch）？
```
不改变源码，在运行时对功能进行追加和变更，达到“hot patch”的目的；
简而言之，猴子补丁就是在运行时对属性做动态修改；
  - 运行时动态替换方法；
  - 运行时动态增加方法；
使用Monkey Patch虽然可以动态改变对象属性，快速实现某些功能，但同时也有破坏代码整洁性的风险；
```

### 15 - 什么是类型约束（类型提示）？
```
类型约束（类型提示）是说可以在函数、方法、类的参数和返回值声明其类型，帮助编辑器提供更精准的提示；
具体信息可查看：PEP484：https://www.python.org/dev/peps/pep-0484/；
特别注意：类型约束（类型提示）仅仅是具备了“提示”功能，对于不符合期望的数据类型并不会报错；
```




## 数据文件

### 01 - 如何拷贝一个对象？
```
使用标准库copy模块的copy方法（返回和参数包含内容一样的对象）和deepcopy方法（对象中的属性也被复制）；
并不是所有对象都可以被拷贝；
```

### 02 - 如何查看或判断一个python对象的类型？
```
- 查看对象类型：使用内置type()函数；
- 判断对象类型：使用内置isinstance()函数；
```

### 03 - Python中字符串格式化的方式有哪几种？
```
- 格式化操作符（%）；
- 字符串内建函数format()；
- 使用string模块中的字符串模板（Template）对象；
```

### 04 - 如何移除一个字符串中的前导和后缀字符？
```
使用Istrip()方法可以移除字符串中的前导字符；
使用rstrip()方法可以移除字符串中的后缀字符；
```

### 05 - Pyrhon中如何删除一个列表中的重复元素？
```
使用内置set()函数；
```

### 06 - 如何就地打乱一个列表的元素？
```
使用random模块的shuffle()函数；
```

### 07 - 如何实现数据类型转换？
```
Python中的一些内置函数可以实现数据类型转换；
例如：
  - tuple()和list()函数可以实现元组（tuple）和列表（list）之间数据类型转换；
  - str()可以将一个数字转换成一个字符串；
  - 此外还有bytes()、bytearray()、int()、float()、list()、tuple()、dict()等等；
```

### 08 - 如何生成随机数？
```
使用标准库random模块：https://docs.python.org/3/library/random.html
例如：
  - random.random()：生成一个0-1之间的随机浮点数；
  - random.uniform(a, b)：生成[a,b]之间的浮点数；
  - random.randint(a, b)：生成[a,b]之间的整数；
  - random.randrange(a, b, step)：在指定的集合[a,b)中，以step为基数随机取一个数；
  - random.choice(sequence)：从特定序列中随机取一个元素，这里的序列可以是字符串，列表，元组等；
```

### 09 - 如何在函数中设置一个全局的变量？
```
Python提供了global关键字，能够在函数里面声明或修改全局变量，但不建议这样使用；
实际上，Python的全局变量是模块级别的，而不是程序级别的（全局唯一）；
模块就是一个Python文件，是一个独立的、顶层的命名空间，模块内定义的变量，都属于该命名空间；
```

### 10 - 如何删除、拷贝一个文件？
```
删除文件可使用os.remove()或os.unlink()方法；
拷贝文件可使用标准库shutil模块的copyfile()方法；
```




## 技巧提示

### 01 - 如何处理中文输出问题？
```
使用字符串对象的encode()和decode()方法；
```

### 02 - 如何在函数中设置全局变量？
```
可以使用global语句可以在一个函数里给全局变量赋值；
“global Var”表达式会告诉Python，Var是一个全局变量，Python就不会在局部命名空间里寻找这个变量；
```

### 03 - 如何查看全局范围内的对象？
```
利用内置函数globals()：https://docs.python.org/3/library/functions.html#globals；
```

### 04 - Python如何获取当前的绝对路径？
```
通过标准库os模块的os.path.abspath('.')方法获取；
```

### 05 - Python如何获取当前模块的文件名？
```
通过特殊变量__file__获取；
```

### 06 - 如何遍历一个内部未知的文件夹？
```
常用办法：os.walk()，os.listdir()等；
```

### 07 - Python如何获取命令行参数?
```
通过标准库sys模块的sys.argv变量获取；
```

### 08 - 如何获取当前Python命令的可执行文件路径？
```
通过标准库sys模块的sys.executable变量获取；
```

### 09 - 如何查看所有的已成功加载的模块？
```
通过sys.modules查看；
```

### 10 - 如何实现或支持迭代器协议？
```
在Python3中，支持迭代器协议就是实现对象的__iter__()和__next__()方法；
- __iter__()方法：返回迭代器对象本身；
- __next__()方法：返回容器中的当前元素，并指向下一个元素的位置，当前位置已经没有元素的时候，抛出StopIteration异常终止迭代；
内置函数iter()和next()，本质上都是使用对象的__iter__()、__next__()的方法；
```




## 区别对比

### 01 - Python中的help()和dir()函数的作用与区别？
```
Help()函数：内置函数，用于查看函数或模块用途的详细说明；
Dir()函数：内置函数
  - 不带参数时，返回当前范围内的变量、方法和定义的类型列表；
  - 带参数时，返回参数的属性、方法列表；
```

### 02 - 元组（tuple）与（list）的主要区别？
```
元组（tuple）和（list）的主要区别是列表是可变的，而元组是不可变的；
使用内置tuple()和list()函数可实现数据类型转换；
```

### 03 - 类变量与实例变量的主要区别？
```
类变量：是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）；
实例变量：实例化之后，每个实例单独拥有的变量；
```

### 04 - Python中单下划线和双下划綫的区别？
```
以单下划线开头的成员变量是保护变量，只有类对象和子类对象自己能访问到这些变量；
以双下划线开头的是私有成员，只有类对象自己能访问，连子类对象也不能访问到这个数据；
```

### 05 - Python中变量、对象与引用的关系？
```
- 变量：不需要预先声明，在第一次赋值时被创建并指向对象，变量的类型是动态变化的，其类型与对象保持一致； 
- 对象：被分配的一块内存空间，存储其所代表的值，并且具有类型标识符和引用计数器；
- 引用：从变量到对象的指针； 
总的来说，在Python中变量和对象是分离的，对象是内存中储存数据的实体，变量则是指向对象的指针；类型属于对象，而不是变量；
```

### 06 - 可变对象与不可变对象的定义和区分？
```
不可变对象：
- 调用对象自身的方法，不会改变该对象自身的内容，而是创建新的对象（分配新的内存地址）并返回，保证了不可变对象本身不可变；
- 包括int，float，str，tuple等；

可变对象：
- 调用对象自身的方法，会改变该对象自身的内容（内存地址保持不变）；
- 包括list，set，dict等；

特别注意：
- “不可变”是指“值的不可变”；
- 函数的默认参数必须指向不可变对象；
```

### 07 - Python中赋值、浅拷贝、深拷贝的区别？
```
赋值：
- 创建对象的一个引用；
- 实现赋值可使用“=”；

浅拷贝：
- 复制对象，将一个对象的引用拷贝到另一个对象上，但不复制该对象中引用的其他对象（依然使用原始的引用）；
- 如果在拷贝中改动，会影响到原对象；
- 实现浅拷贝可使用完全切片[:]、使用工厂函数（list()、set()等）、使用copy模块中的copy.copy()；

深拷贝：
- 复制对象，将一个对象拷贝到另一个对象中，同时也复制该对象中引用的其他对象；
- 如果对一个对象的拷贝做出改变时，不会影响原对象；
- 实现深拷贝可使用copy模块的copy.deepcopy()；
```

### 08 - “is”和“==”的区别?
```
- “is”：表示对象标示符（object identity），用来检查对象的标示符（内存中的地址）是否一致；
- “==”：表示相等（equality），用来检查两个对象的值是否相等；
```

### 09 - Python多线程与多进程的主要区别？
```
多线程可以共享全局变量，多进程不能；
多线程的所有子线程的进程号相同，多进程的不同的子进程进程号不同；
```

### 10 - 生成器(generator)与函数的主要区别？
```
生成器是包含yield关键字的函数，在运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值；
生成器返回迭代器，而函数返回值；
```

### 11 - re.match()和re.search()方法的不同？
```
- re.match()：只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
- re.search()：扫描整个字符串并返回第一个成功的匹配；
```

### 12 - Python新式类与经典类（旧式类）的区别？
```
在多继承中，新式类采用广度优先搜索，而旧式类是采用深度优先搜索；
新式类更符合OOP编程思想，统一了python中的类型机制（直接通过__class__属性获取自身类型与type()的结果一致）；
相同父类的场景，新式类只执行一次构造函数，经典类重复执行多次；
新式类增加了一些内置属性和方法，例如：__slots__内置属性和__getattribute__方法；
Python2.x中默认都是经典类，只有显式继承了object才是新式类；Python3.x中默认都是新式类，经典类被移除，不必显式的继承object；
```

### 13 - “__new__”与“__init__"的区别？
```
“__new__”：
- 用来构造函数，只有继承了object的新式类才有__new__；
- 实例创建之前被调用，有返回值，创建实例然后返回该实例； 
- 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供；

“__init__”：
- 只是初始化方法，在__new__的基础上可以完成一些其它初始化的动作，真正构造函数的是__new__方法；
- 实例对象创建完成后被调用，设置对象属性的一些初始值，无返回值；
- 参数self是__new__返回的实例，先运行__new__后运行__init__；

也就是说，__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数；
```

### 14 - “@classmethod”、“@staticmethod”和“@property”的区别？
```
都是装饰器（decorator），其使用对象是在类中定义的函数；
装饰器是一种特殊的函数，要么接受函数作为输入参数，并返回一个函数，要么接受一个类作为输入参数，并返回一个类；
“@”标记是语法糖（syntactic sugar），能够以简单易读的方式装饰目标对象；
@classmethod：类方法
  - 在class中第一个参数为self的方法全部是实例方法，self绑定实例本身;
  - 可以通过标记一个@classmethod将一个方法绑定到类上，而非类的实例；
  - 类方法的第一个参数将传入类本身，通常将参数名命名为cls；
  - 类方法是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用；
@staticmethod：静态方法
  - 用@staticmethod装饰，可以被实例对象访问或直接访问；
  - 静态方法和普通方法一样，不需要进行绑定；
@property：属性
  - 在对实例属性操作的时候，该属性很可能不是直接暴露的，而是通过get和set方法来实现的；
  - Python内置的@property装饰器可以把一个方法变成属性调用；
  - @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样程序运行时就减少了出错的可能性；
```

### 15 - 参数“*args”和“**kwargs”的区别？
```
如果不确定要往函数中传入多少个参数，或者想以列表和元组的形式往函数中传参数时，使用“*args”；
如果不确定要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，使用“**kwargs”；
约定俗成使用args和kwargs这两个标识符，也可以用其他标识符名称（不建议）；
“*args”和“**kwargs”可以同时在函数的定义中，但“*args”必须放置在“**kwargs”前面；
```
