# Confusing_Code_Tips



### 01
```
试图访问一个超过列表索引值的成员将导致“IndexError”。
访问一个起始索引超出列表成员数的列表切片将仅仅返回一个空列表。
```

### 02
```
列表的切片操作重新分配了对象。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

### 03
```
注意区分是对同一个列表的多次引用，还是独立的多个列表。
例如“tl = [[]] * 3”实际上是一个创建了包含对同一个列表引用3次的列表。
```

### 04
```
列表的解析、交集与差集。
```

### 05
```
列表与元组的定义。
```

### 06
```
在Python3中“/ ”操作符是做浮点除法，而在Python2中则是整除。
“//”操作符总是做整除，但Python的整除运算会向0的方向取值。
```

### 07
```
在Python中，类变量在内部是作为字典处理的，如果一个变量名没有在当前类的字典中发现，将搜索祖先类直到被引用的变量名被找到。
如果这个被引用的变量名没找到，将会引发“AttributeError”异常。
在父类中设置一个类变量的值，那么其任何子类中均默认继承此变量的值。
如果子类重写了此变量值，那么该值仅仅在子类中被改变。
如果此变量值在父类中被改变，这个改变只会影响到任何未重写该变量值的子类。
```

### 08
```
lambda函数是一种快速定义单行的最小函数。
Python闭包的延迟绑定（late binding）：内部函数被调用时，参数的值在闭包内进行查找。
避免此问题的方法：使用Python生成器和yield关键字，或者在闭包中使用默认参数立即绑定它的参数。
```

### 09
```
引用的含义。
短字符串驻留机制。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

### 10
```
对象分为“不可更改”（immutable）和“可更改”（mutable）对象。
不可变对象调用对象自身的方法，不会改变该对象自身的内容，而是创建新的对象并返回，这样就保证了不可变对象本身永远不可变。
可变对象调用对象自身的方法，会改变该对象自身的内容。
```

### 11
```
类型是属于对象的，而不是变量。
在python中，strings、tuples和numbers是不可更改的对象，而list、dict等则是可更改的对象。
```

### 12
```
可变类型对象与不可变类型对象的区别；
赋值（=）只是建立一个引用；
完全切片“[:]”实际完成了浅拷贝的过程，会生成一个新的对象；
```

### 13
```
类变量(供类使用的变量)与实例变量（供实例使用的变量）的关系。
```

### 14
```
引用的含义。
浅拷贝copy.copy()：仅拷贝对象本身，而不拷贝对象中引用的其它对象，对于对象中的元素依然使用原始的引用。
深度拷贝copy.deepcopy()：拷贝对象本身和对象中引用的其它对象，也就是复制容器对象以及里面的所有元素（包含元素的子元素）。
```

### 15
```
引用的含义。
浅拷贝copy.copy()：仅拷贝对象本身，而不拷贝对象中引用的其它对象，对于对象中的元素依然使用原始的引用。
深度拷贝copy.deepcopy()：拷贝对象本身和对象中引用的其它对象，也就是复制容器对象以及里面的所有元素（包含元素的子元素）。
```

### 16
```
zip函数和列表解析（List Comprehension）的使用方法。
```

### 17
```
继承的定义和super函数的用法。
```

### 18
```
不可变对象与可变对象的定义与区别。
```

### 19
```
不可变对象与可变对象的定义与区别。
赋值、浅拷贝与深拷贝的区别。
```

### 20
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
默认参数的默认值在函数创建的时候就生成了，每次调用都是用了这个对象的缓存。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
```

### 21
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
```

### 22
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
传入None作为默认参数，在创建对象的时候动态生成列表。
```

### 23
```
列表被实例化为函数定义的一部分，函数会一直使用同一个列表对象（列表并不是在每次函数运行时都被实例化），除非提供一个新的对象。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
对于不可变数据类型（比如元组、字符串、整型），则不会出现类似问题。
```

### 24
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议“将可变类型数据作为类变量”。
```

### 25
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议“将可变类型数据作为类变量”。
```

### 26
```
逻辑运算与顺序。
```

### 27
```
变量及全局变量的定义。
```

### 28
```
全局变量的定义与调用。
```

### 29
```
不推荐在finally中使用return返回，将会导致很多问题；
- try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行；
- try块中抛出异常被except捕获，finally中的语句在except块return之前执行，except中的return被忽略；
- 不论异常有没有被捕获，finally中的语句都会执行;
```

### 30
```
“__new__”与“__init__”方法的定义与区别。
```

### 31
```
如果类中没有定义的方法可调用时，将调用“__getattr__”方法。
```

### 32
```
多重继承、新式类与super()。
```