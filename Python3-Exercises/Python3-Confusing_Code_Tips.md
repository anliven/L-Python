# Confusing_Code_Tips



### 01
```
试图访问一个超过列表索引值的成员将导致“IndexError”。
访问一个起始索引超出列表成员数的列表切片将仅仅返回一个空列表。
```

### 02
```
列表的切片操作重新分配了对象。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

### 03
```
注意区分是对同一个列表的多次引用，还是独立的多个列表。
```

### 04
```
列表的解析、交集与差集。

```

### 05
```
列表与元组的定义。
```

### 06
```
在Python3中“/ ”操作符是做浮点除法，而在Python2中则是整除。
“//”操作符总是做整除，但Python的整除运算会向0的方向取值。
```

### 07
```
在Python中，类变量在内部是作为字典处理的，如果一个变量名没有在当前类的字典中发现，将搜索祖先类直到被引用的变量名被找到。
如果这个被引用的变量名没找到，将会引发“AttributeError”异常。
在父类中设置一个类变量的值，那么其任何子类中均默认继承此变量的值。
如果子类重写了此变量值，那么该值仅仅在子类中被改变。
如果此变量值在父类中被改变，这个改变只会影响到任何未重写该变量值的子类。
```

### 08
```
lambda函数是一种快速定义单行的最小函数。
Python闭包的延迟绑定（late binding）：内部函数被调用时，参数的值在闭包内进行查找。
避免此问题的方法：使用Python生成器和yield关键字；或者在闭包中，使用默认参数立即绑定它的参数。
```

### 09
```
引用的含义。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

### 10
```
对象分为“不可更改”（immutable）和“可更改”（mutable）对象。
不可变对象调用对象自身的方法，不会改变该对象自身的内容，而是创建新的对象并返回，这样就保证了不可变对象本身永远不可变。
可变对象调用对象自身的方法，会改变该对象自身的内容。
```

### 11
```
类型是属于对象的，而不是变量。
在python中，strings、tuples,和numbers是不可更改的对象，而list、dict等则是可更改的对象。
```

### 12
```
可变类型对象与不可变类型对象的区别；
赋值（=）只是建立一个引用；
完全切片“[:]”实际完成了浅拷贝的过程；
```

### 13
```
类变量(供类使用的变量)与实例变量（供实例使用的变量）的关系。
```

### 14
```
引用的含义。
copy仅拷贝对象本身，而不拷贝对象中引用的其它对象。
deepcopy除拷贝对象本身，而且拷贝对象中引用的其它对象。
```

### 15
```
引用的含义。
copy仅拷贝对象本身，而不拷贝对象中引用的其它对象。
deepcopy除拷贝对象本身，而且拷贝对象中引用的其它对象。
```

### 16
```
zip函数和列表解析（List Comprehension）的使用方法。
```

### 17
```
继承的定义和super函数的用法。
```

### 18
```
不可变对象与可变对象的定义与区别。
```

### 19
```
不可变对象与可变对象的定义与区别。
赋值、浅拷贝与深拷贝的区别。
```

### 20
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议”将可变数据类型作为函数定义中的默认参数“。
```

### 21
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议”将可变数据类型作为函数定义中的默认参数“。
```

### 22
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议”将可变数据类型作为函数定义中的默认参数“。
```

### 23
```
列表被实例化为函数定义的一部分，函数会一直使用同一个列表对象（列表并不是在每次函数运行时都被实例化），除非提供一个新的对象。
不建议”将可变数据类型作为函数定义中的默认参数“。
对于不可变数据类型（比如元组、字符串、整型），则不会出现类似问题。
```

### 24
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议”将可变类型数据作为类变量“。
```

### 25
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议”将可变类型数据作为类变量“。
```

### 26
```
逻辑运算与顺序。
```
