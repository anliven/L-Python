# Confusing_Code_Tips



## 01
```
试图访问一个超过列表索引值的成员将导致“IndexError”。
访问一个起始索引超出列表成员数的列表切片将仅仅返回一个空列表。
```

## 02
```
列表的切片操作重新分配了对象。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

## 03
```
注意区分是对同一个列表的多次引用，还是独立的多个列表。
例如“tl = [[]] * 3”实际上是一个创建了包含对同一个列表引用3次的列表。
```

## 04
```
列表的解析、交集与差集。
```

## 05
```
列表与元组的定义。
```

## 06
```
在Python3中“/ ”操作符是做浮点除法，而在Python2中则是整除。
“//”操作符总是做整除，但Python的整除运算会向0的方向取值。
```

## 07
```
在Python中，类变量在内部是作为字典处理的，如果一个变量名没有在当前类的字典中发现，将搜索祖先类直到被引用的变量名被找到。
如果这个被引用的变量名没找到，将会引发“AttributeError”异常。
在父类中设置一个类变量的值，那么其任何子类中均默认继承此变量的值。
如果子类重写了此变量值，那么该值仅仅在子类中被改变。
如果此变量值在父类中被改变，这个改变只会影响到任何未重写该变量值的子类。
```

## 08
```
lambda函数是一种快速定义单行的最小函数。
Python的属性查找规则（LEGB，local enclousing global bulitin）。
Python的闭包是延迟绑定（late binding）：闭包中变量的值，是在内部函数被调用时查询得到的。
避免此问题的方法：使用Python生成器和yield关键字，或者在闭包中使用默认参数立即绑定它的参数（闭包作用域变为局部作用域）。
```

## 09
```
引用的含义。
短字符串驻留机制。
- “is”对比内存地址：是否完全相同，是否同一个对象；
- “==”对比值：内容是否相等（内存地址可以不同）；
```

## 10
```
对象分为“不可更改”（immutable）和“可更改”（mutable）对象。
不可变对象调用对象自身的方法，不会改变该对象自身的内容，而是创建新的对象并返回，这样就保证了不可变对象本身永远不可变。
可变对象调用对象自身的方法，会改变该对象自身的内容。
```

## 11
```
类型是属于对象的，而不是变量。
在python中，strings、tuples和numbers是不可更改的对象，而list、dict等则是可更改的对象。
```

## 12
```
可变类型对象与不可变类型对象的区别；
赋值（=）只是建立一个引用；
完全切片“[:]”实际完成了浅拷贝的过程，会生成一个新的对象；
```

## 13
```
类变量(供类使用的变量)与实例变量（供实例使用的变量）的关系。
```

## 14
```
引用的含义。
浅拷贝copy.copy()：仅拷贝对象本身，而不拷贝对象中引用的其它对象，对于对象中的元素依然使用原始的引用。
深度拷贝copy.deepcopy()：拷贝对象本身和对象中引用的其它对象，也就是复制容器对象以及里面的所有元素（包含元素的子元素）。
```

## 15
```
引用的含义。
浅拷贝copy.copy()：仅拷贝对象本身，而不拷贝对象中引用的其它对象，对于对象中的元素依然使用原始的引用。
深度拷贝copy.deepcopy()：拷贝对象本身和对象中引用的其它对象，也就是复制容器对象以及里面的所有元素（包含元素的子元素）。
```

## 16
```
zip函数和列表解析（List Comprehension）的使用方法。
```

## 17
```
继承的定义和super函数的用法。
```

## 18
```
不可变对象与可变对象的定义与区别。
```

## 19
```
不可变对象与可变对象的定义与区别。
赋值、浅拷贝与深拷贝的区别。
```

## 20
```
默认参数是在定义的时候求值，而不是在被调用的时候。
默认参数的默认值在函数创建的时候就生成了，每次调用都是用了这个对象的缓存。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
```

## 21
```
默认参数是在定义的时候求值，而不是在被调用的时候。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
```

## 22
```
带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
传入None作为默认参数，在创建对象的时候动态生成列表。
```

## 23
```
列表被实例化为函数定义的一部分，函数会一直使用同一个列表对象（列表并不是在每次函数运行时都被实例化），除非提供一个新的对象。
不建议“将可变数据类型作为函数定义中的默认参数”，除非特殊需要。
对于不可变数据类型（比如元组、字符串、整型），则不会出现类似问题。
```

## 24
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议“将可变类型数据作为类变量”。
```

## 25
```
创建类定义时，列表将被实例化，该类所有的实例使用相同的列表。
不建议“将可变类型数据作为类变量”。
```

## 26
```
逻辑运算与顺序。
```

## 27
```
变量及全局变量的定义。
```

## 28
```
全局变量的定义与调用。
```

## 29
```
不推荐在finally中使用return返回，将会导致很多问题；
- try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行；
- try块中抛出异常被except捕获，finally中的语句在except块return之前执行，except中的return被忽略；
- 不论异常有没有被捕获，finally中的语句都会执行;
```

## 30
```
“__new__”与“__init__”方法的定义与区别。
```

## 31
```
如果类中没有定义的方法可调用时，将调用“__getattr__”方法。
```

## 32
```
多重继承、新式类与super()。
```

## 33
```
生成器是按需生成，不保留迭代过后的结果。
如果要保留迭代后的结果，可将其转化为列表或元组，循环后值还在。
```

## 34
```
Lambda在闭包中会保存局部变量。
```

## 35
```
利用iter()和zip()实现了一个分组函数。
```

## 36
```
在循环中对列表元素做remove操作影响了列表的index。
```

## 37
```
"+="是对原列表操作，而“+”改变了原列表。
append()和extend()都是对原列表操作。
```

## 38
```
bool其实是int的子类， True和False也可以进行数值计算。
```

## 39
```
虽然元组是不可变类型，不能直接操作元组，但可以操作元组中的可变子对象。
对元组执行“+=”等操作，实际上是创建了新元组，而不是改变了原来的元组。
```

## 40
```
特殊浮点数的定义与计算。
NaN值的比较操作总是返回False。
```

## 41
```
生成器是迭代器，而迭代器是一次性的，不能重新加载，也就是说同一个迭代器对象无法多次迭代；
内部工具(for循环、sum、min、max等)使用迭代器协议访问对象；

for循环的本质就是遵循迭代器协议去访问对象，Python中所有形式的迭代都是由迭代器协议驱动的；
- 迭代器是惰性可迭代对象（延迟工作直到请求下一项）；
- 迭代器是有状态的（一次性使用），意味着只能循环遍历一次，一旦从中遍历了一项，这一项就消失了；
- 迭代器没有长度（可以创建无限长的迭代器），不能被索引；
```

## 42
```
拆包字典时，将会得到键，而不是键值对；
```