# Python3-Questions_In_A_Word



## 001-010

### 001 - 如何拷贝一个对象？
使用标准库copy模块的copy方法（返回和参数包含内容一样的对象）和deepcopy方法（对象中的属性也被复制）。
### 002 - pass语句的作用是什么？
pass语句一般用来作为占位符或者创建占位代码块，pass语句不会执行任何操作。
### 003 - Pyrhon中如何删除一个列表中的重复元素？
使用内置set()函数。
### 004 - 如何实现元组（tuple）和（list）之间的数据类型转换？
使用内置tuple()和list()函数。
### 005 - Lambda函数的定义？
Lambda函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的单行函数(也称为匿名函数)，所包含的表达式不能超过一个，而且不能包含命令。
### 006 - 如何查看一个python对象的类型？
使用内置type()函数。
### 007 - 如何生成随机数？
使用标准库random模块。
### 008 - Python代码检查和分析工具有那些？
PyChecker（http://pychecker.sourceforge.net/）和PyLint（https://pylint.org/）。
### 009 - 如何在函数中设置一个全局的变量？
使用global语句可以声明全局变量，但不建议这样使用。
### 010 - 如何删除一个文件？
使用os.remove()或os.unlink()方法。



## 011-020

### 011 - 如何拷贝一个文件？
使用标准库shutil模块的copyfile()方法。
### 012 - 如何处理中文输出问题？
使用字符串对象的encode()和decode()方法。
### 013 - 切片（Slicing）的含义？
Slicing是一种能够在有序的对象类型（列表，元组，字符串）中截取指定索引范围内容的语法，可以很方便地获取序列的子序列。
### 014 - 什么是PEP8？
```
PEPs(Python Enhancement Proposals，https://www.python.org/dev/peps/)。
PEP8(Style Guide for Python Code)是一个编程规范，关于如何让代码更具有可读性的一些建议。
具体信息（https://www.python.org/dev/peps/pep-0008/）。
```
### 015 - 文档字符串（docstring）的含义？
文档字符串（docstring）为函数，模块和类注释生成文档。
### 016 - 如何将一个数字转换成一个字符串？
使用内置函数str()。
### 017 - Python装饰器的作用？
简单来说，装饰器的作用就是为已经存在的对象添加额外的功能，可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。
### 018 - Python多线程与多进程的主要区别？
多线程可以共享全局变量，多进程不能；多线程的所有子线程的进程号相同，多进程的不同的子进程进程号不同。
### 019 - 生成器(generator)与函数的主要区别？
生成器是包含yield关键字的函数，在运行过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值；生成器返回迭代器，而函数返回值。
### 020 - re.match()和re.search() 方法的不同？
```
re.match()只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
re.search()  扫描整个字符串并返回第一个成功的匹配。
```


## 021-030

### 021 - 什么是pickling与unpickling？
```
将内容从内存中变成可存储或传输的过程称之为序列化（pickling），反之，把内容从序列化的对象重新读到内存里称之为反序列化（unpickling）。
标准库pickle模块可用来实现持久地（Persistently）存储任何纯Python对象到文件并读取。
```
### 022 - 如何理解“Python是一种解释型、交互式、面向对象、动态数据类型的高级程序设计语言”？
```
- 解释型：源代码先翻译成中间代码，再由解释器对中间代码进行解释运行；源代码在执行之前不需要编译，直接运行。
- 交互式：编写代码时可通过终端和解释器直接交互。
- 面向对象：在Python中所有的一切都是对象，包括数字、字符串与函数。
- 动态数据类型：变量不需要指定类型（编译时编译器并不知道变量的真实类型, 只有在运行时才知道其真实类型）。
- 高级程序设计语言：良好的可移植性（不依赖于具体的机器）、丰富的数据结构和控制结构、良好的可读性（便于交流和维护）。
```
### 023 - Python命名空间的含义？
```
命名空间是名称到对象的映射，是一个字典的实现，键为变量名，值是变量对应的值。
各个命名空间是独立存在，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。
- Local（局部命名空间）：运行阶段函数被调用时动态创建，记录函数中定义的所有变量，函数调用结束时动态销毁。
- Global（全局命名空间）：模块被加载时创建，记录模块中定义的变量，通常一直保留直到python解释器退出。
- Built-in（内建命名空间）：python解释器启动时创建，记录内置函数和异常，一直保留直到解释器退出。
命名空间创建顺序：python解释器启动->创建内建命名空间->加载模块->创建全局命名空间->函数被调用->创建局部命名空间
命名空间销毁顺序：函数调用结束->销毁函数对应的局部命名空间->python虚拟机（解释器）退出->销毁全局命名空间->销毁内建命名空间
```
### 024 - Python作用域的含义？
```
作用域是针对变量而言，指声明的变量在程序里的可应用范围，变量的作用域总是由在代码中被赋值的地方所决定的。
搜索顺序：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）。
```
### 025 - Python新式类与经典类（旧式类）的区别？
```
在多继承中，新式类采用广度优先搜索，而旧式类是采用深度优先搜索。
新式类更符合OOP编程思想，统一了python中的类型机制（直接通过__class__属性获取自身类型与type()的结果一致）。
相同父类的场景，新式类只执行一次构造函数，经典类重复执行多次。
新式类增加了一些内置属性和方法，例如：__slots__内置属性和__getattribute__方法。
Python2.x中默认都是经典类，只有显式继承了object才是新式类；Python3.x中默认都是新式类，经典类被移除，不必显式的继承object。
```
### 026 - Python如何获取当前的绝对路径？
通过标准库os模块的os.path.abspath('.')方法获取。
### 027 - Python如何获取当前模块的文件名？
通过特殊变量__file__获取。
### 028 - Python如何获取命令行参数?
通过标准库sys模块的sys.argv变量获取。
### 029 - 如何获取当前Python命令的可执行文件路径？
通过标准库sys模块的sys.executable变量获取。
### 030 - 参数“*args”和“**kwargs”的区别？
```
如果不确定要往函数中传入多少个参数，或者想往函数中以列表和元组的形式传参数时，使用“*args”。
如果不确定要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，使用“**kwargs”。
约定俗成使用args和kwargs这两个标识符，也可以用其他标识符名称（不建议）。
```



## 031-040

### 031 - Python中GIL（Global Interpreter Lock）的作用？
GIL会确保任何时候，多个线程中只有一个线程被执行。也就是说，由于GIL的限制，Python并不支持真正意义上的多线程。
### 032 - Python中装饰器（decorator）的定义？
```
装饰器是一种特殊的函数，可以接受函数作为输入参数，并返回一个函数，也可以接受一个类作为输入参数，并返回一个类。
通过使用@标记（语法糖，syntactic sugar），能够以简单易读得方式装饰目标对象。
```
### 033 - 如何理解Python中函数是第一类对象（first-class objects）？
```
函数既能返回函数类型，也可以接受函数作为输入，还可以指定给变量。
Python中的类（class）也是第一类对象。
```
